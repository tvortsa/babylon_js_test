<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Babylon Template</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>

</head>

<body>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas"); // получаем элемент canvas
        const engine = new BABYLON.Engine(canvas, true, { stencil: true }); // генерируем 3D сцену BABYLON

        // свой код

        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            // Add a camera to the scene and attach it to the canvas
            // var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            // const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
            const camera = new BABYLON.ArcRotateCamera("camera", 3, Math.PI / 2.5, 5, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            camera.wheelPrecision = 50

            // Add a lights to the scene
            // var light = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(0, 1, 0), scene);
            var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);

            //Your Code
            // Добавляем и манипулируем каркасом в сцене
            // var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1 }, scene);

            // hilight layer
            // Add the highlight layer.
            var hl = new BABYLON.HighlightLayer("hl1", scene);
            scene.hl2 = new BABYLON.HighlightLayer("hl2", scene);
            var _current_mesh

            // интерактив
            let switched = false;  //on off flag
            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if (pointerInfo.pickInfo.hit) {
                            pointerDown(pointerInfo.pickInfo.pickedMesh)
                        } else {
                            pointerDown(false)
                        }
                        break;
                }
            });

            const pointerDown = (mesh) => {
                if (_current_mesh) {                // 
                    if (_current_mesh !== mesh) {
                        hl.removeMesh(_current_mesh); // гасим предыдущий активный меш
                        _current_mesh = mesh            // делаем активным пикнутый сейчас меш
                        console.log(`пикнут меш с именем: ${_current_mesh.name}`);
                        // console.log(`первое наведение на меш: ${mesh.name}`);
                        hl.addMesh(_current_mesh, BABYLON.Color3.Green()); // зажигаем новый активный меш
                    } else {                            // если предыдущий текущий меш - false
                        if (mesh) {                     // но какой-то меш пикнут
                            _current_mesh = mesh        // присваиваем этот меш активному мешу
                            hl.addMesh(_current_mesh, BABYLON.Color3.Green()); // зажигаем новый активный меш
                        } else {
                            hl.removeMesh(mesh);
                        }
                    }
                } else {
                    if (mesh) {                     // но какой-то меш пикнут
                        _current_mesh = mesh        // присваиваем этот меш активному мешу
                        hl.addMesh(_current_mesh, BABYLON.Color3.Green()); // зажигаем новый активный меш
                    }
                }
                if (_current_mesh) {
                    if (!mesh) {
                        hl.removeMesh(_current_mesh); // гасим предыдущий активный меш
                    }
                }
            }

            
            //GUI
            
            scene.popup_tooltip = function (mesh) {
                let _text = 'вы только что подсветили объект: ' + name
                // rect1 И text1 из tooltip.js
             console.log(`текст из объекта text1, файлы tooltip.js: ${text1.text}`);
            }
             

            return scene;
        };

        const scene = createScene(); //вызываем функцию createScene



        let _turbine
        BABYLON.SceneLoader.ImportMeshAsync("", "/", "turbineJS.gltf").then((result) => {
            // result.meshes[1].position.x = 20;
            // const myMesh_1 = scene.getMeshByName("myMesh_1");
            // myMesh1.rotation.y = Math.PI / 2;
            console.dir(`Имя первого меша: ${result.meshes[1].name}`);

            let _meshes = result.meshes
            _meshes.forEach(mesh => {
                mesh.actionManager = new BABYLON.ActionManager(scene);
                mesh.actionManager
                .registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPointerOverTrigger,
                        function () {
                            scene.hl2.removeAllMeshes()
                            scene.hl2.addMesh(mesh, BABYLON.Color3.Red()) // зажигаем новый активный меш
                            scene.popup_tooltip(mesh)
                        }
                    )
                )
                .then(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPointerOutTrigger,
                        function () {scene.hl2.removeMesh(mesh)} // зажигаем новый активный меш
                    )
                )
            });
            console.log('модель загружена');
        });

        // регистрируем цикл рендеринга для многократного рендеринга сцены
        engine.runRenderLoop(function () {
            scene.activeCamera.alpha += .0003;
            scene.render();
        });
        // следим за событиями изменения размера браузера/canvas`а 
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>